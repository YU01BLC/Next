# Vite について

## 概要

非常に高速な Hot Module Replacement (HMR) など、Native ES Module を利用した豊富な機能拡張を提供する開発サーバ。

- Hot Module Replacement (HMR):

  - Hot Reload と同じでリアルタイムで変更を反映させるツール
  - フロントエンド言語/フレームワークと組み合わせるツール
  - アプリケーション全体ではなく、モジュール単位(React でいうコンポーネント単位)での変更を検知する

- Native ES Module:
  - コードを整理し、再利用可能な部品単位で分割する仕組み
  - フロントエンド開発において広く用いられている、 import 宣言でインポートし export 宣言でエクスポートするもの

Rollup でコードをバンドルするビルドコマンド。プロダクション用に高度に最適化された静的アセットを出力するように事前に設定されている。

- Rollup:
  - 複数ファイルに分散した JavaScript コードを、モジュールを読み込みながら 1 つのバンドルにまとめるツール
  - コードの小さな部分をライブラリやアプリケーションなど、より大きくて複雑なものにコンパイルする
  - webpack のようなもの

### vite 導入について

Next.js のデフォルトビルドシステムから Vite に切り替えることによって想定されるメリット・デメリットをまとめる

#### Next ビルドシステムとの比較

- 高速な開発サーバの提供: ファイルの変更を検知し即座に反映させる。Next は webpack ベースのビルドシステムを採用しており、それより高速にリアルタイムで変更を反映させることが可能。

- Next は Webpack ベースのビルドシステムであり、多くのプラグインや設定を提供している。比べ Vite は設定がシンプルでわかりやすい
- Vite は ES モジュールにフォーカスしており、モジュールの解決が高速に行われる。Next も同様のサポートがあるが速度面で劣っている
- Vite は production build の処理速度を改善することに対しては課題を抱えており、現状使用する大きなメリットは主に Local での開発となる
- 利用率は webpack の方が圧倒的に高いが、注目度・満足度では Vite がまさっている。今後率先的に活用される可能性がありそう。[stateofjs](https://2021.stateofjs.com/ja-JP/libraries/build-tools/) 参照

#### 導入注意

- Next サーバーサイドレンダリングや API ルートなどの機能があり、Vite ではこれらの機能が制限される。
  - Vite は、Node.js 上で実行されないため、サーバーサイドレンダリング機能を使用することができない。
  - Vite は webpack に依存しないため、カスタム webpack の構成と Vite が衝突しないよう設計する必要がある
- API ルートを共有する際にポートが競合してしまう可能性がある。また、CORS 問題を回避するためにも適切なポート設定が必要になる。

**対策**

- Vite は、開発環境でのみ使用することが推奨される。
- プロダクション環境では、Next.js が提供するビルド機能を使用する方が良い。(一般的な手法)

### まとめ

- vite は高速で開発環境においては積極的導入を推奨されている
- プロダクションに関しては使用するメリットが薄い
- 開発環境は vite。プロダクションは next(webpack)という構成がベターと言える

# TestingLibrary について

## 概要

Next で使用される TestingLibrary について調査を行う。
Next/TypeScript での開発において最も一般的な Library を選択してベストプラクティスを模索する

### Vitest

- Vite を利用したテストフレームワーク
  - 更新頻度は高いが、安定バージョンが 1.0.0 に到達していない。そのため選定するにはそれなりにリスクもありそう
  - Jest が大規模に採用されていることを考慮して、Vitest は互換性のある API を提供しいる。ほとんどのプロジェクトで Jest をドロップイン代替品(簡単に導入できるの意)として使用可能。

### TestingLibrary/Jest

- Js フレームワーク(React,Vue,Angular, Svelte)向けのテストフレームワーク
  - コンポーネントテストに特化したツール
  - 実際の DOM 要素を操作してアクセシビティを確認する
  - **一般的に Jest との組み合わせで使用する**
    - Jest: ユニットテスト/結合テスト/バックエンドテストなど、主にコードの正確性を確認するために用いる
    - モックやスパイを使用して外部リソースや依存関係を制御し、テストケースを assertion(条件が満たされているかの確認。満たされていない場合エラーメッセージを出力する)する。
      - モック: リアルオブジェクトや機能を仮想的に置き換え、テスト時に外部依存関係やコンポーネントを模倣するもの。
      - スパイ: 関数やメソッドの呼び出し情報を追跡し、テスト実行中に呼び出しを確認する

簡単理解として、TestingLibrary はコンポーネントの表示をチェックするテストで、Jest はコードが正確なことを確認して、適切に関数やメソッドが参照されていることを確認するテスト。故に 2 つのツールを組み合わせて使用する必要がある

### MSW(Mock Service Worker)

- フロントエンドアプリケーションにおいてモックサーバを提供し、主にネットワークリクエストやモックの制御に使用される。(厳密に言うと TestingLibrary ではない)

  - 実際のネットワークをモックとして置き換え、外部へのリクエストをシミュレートすることができる
  - リクエストとレスポンスを視覚化し、デバッグ/テストを容易にする
  - TestingLibrary/Jest などと組み合わせて使用するのが一般的。

簡単理解として、非同期処理や API 通信、ネットワークトラフィックなどを管理・制御するツール
